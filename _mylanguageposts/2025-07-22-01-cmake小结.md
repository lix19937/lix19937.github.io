---
title: 'cmake小结'
date: 2025-07-22
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true

permalink: /mylanguageposts/2025/07/cmake小结/
tags:
  - sdk

---

本文介绍cmake 一些使用技巧。


## cmake 设置rpath     
第一步：在cmake开始时设置，让编译出来的动态库不要将编译时路径添加到RPATH中。
```
set(CMAKE_SKIP_RPATH TRUE)
```

第二步：在 add_library 之后，target_link_libraries 之前，设置下面的属性，让当前动态库查找依赖库时从 …/lib或者./lib查找。这样哪怕有多级依赖，最后我们打包可执行程序时，只需要将所有的动态库放到lib目录，可执行程序放到bin目录即可（可选）。–disable-new-dtags 的作用是不要使用run-path,统一使用rpath。
```
set_target_properties(gbbase PROPERTIES LINK_FLAGS "-Wl,--disable-new-dtags")
set_target_properties(gbbase PROPERTIES LINK_FLAGS "-Wl,-rpath=../lib:./lib")

```

configure 方式设置rpath
通过configure方式编译的动态库有其他依赖库，为了让参与当前编译的库和其依赖库都具有rpath属性。可以这样设置
```
./configure --prefix=${PWD}/build LDFLAGS=-Wl,-rpath=../lib:./lib

```
最终在部署时，只需要将库放到lib目录即可。

## 依赖传递   
PUBLIC 可以将子模块的依赖传递给当前模块，避免当前模块引入二级依赖的头文件和库。但是一般情况下请尽量使用PRIVATE,避免依赖污染。
如：
```
target_include_directories(gbbase PUBLIC    ${CMAKE_SOURCE_DIR}/src/base
                                            ${CMAKE_SOURCE_DIR}/src/controls
                                            ${CMAKE_SOURCE_DIR}/3rd
                                            ${CMAKE_SOURCE_DIR}/3rd/single_include)
                                            
target_link_libraries(gbbase PUBLIC Qt${QT_VERSION_MAJOR}::Widgets Qt${QT_VERSION_MAJOR}::Sql base controls)

```
include当前目录   
```
set(CMAKE_INCLUDE_CURRENT_DIR ON)
```

## 文件递归搜索   
```
file(GLOB_RECURSE Header_files "${CMAKE_CURRENT_SOURCE_DIR}/src/*.h")
file(GLOB_RECURSE Souce_files "${CMAKE_CURRENT_SOURCE_DIR}/src/*.c"  "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")

```

## cmake添加自定义宏    
1、命令行添加（有参）    

-DDROP_COUNT=10

则在cmakelist.txt中这样判断   
```
if(DEFINED DROP_COUNT)
    message(DROP_COUNT: ${DROP_COUNT})
endif()


if(DEFINED DROP_COUNT)
    add_definitions(-DDROP_COUNT=${DROP_COUNT})
    message(DROP_COUNT: ${DROP_COUNT})
endif()

```


然后在代码中这样判断    
```
#ifdef DROP_COUNT
    int dropcount = DROP_COUNT;
#else
    int dropcount = 15;
#endif

```

2、命令行添加（无参）   
-DTEST_OUTPUT=ON

则在cmakelist.txt中这样判断
```
if(TEST_OUTPUT)
add_definitions(-DOPEN_TEST)
endif()

```

然后在代码中这样判断    
```cpp
#ifdef OPEN_TEST
#endif

```

## 指定程序输出路径    
```
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/output/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/output/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/output/bin)

```

## cmake 执行自定义脚本   
```
execute_process(COMMAND sh build.sh "${CMAKE_SOURCE_DIR}/output"
                WORKING_DIRECTORY 脚本路径
                RESULT_VARIABLE SCRIPT_RESULT
                OUTPUT_VARIABLE SCRIPT_OUTPUT)

message(STATUS "OUTPUT: ${SCRIPT_OUTPUT}")
message(STATUS "RESULT: ${SCRIPT_RESULT}")


```
在 ${CMAKE_SOURCE_DIR}/3rd/ddcutil-2.1.4-release/ 路径下，使用 sh 执行 build.sh 这个脚本，并给脚本传递参数： ${CMAKE_SOURCE_DIR}/output ，最后打印脚本的执行结果和输出。




